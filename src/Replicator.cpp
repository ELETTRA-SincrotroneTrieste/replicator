static const char *RcsId =
        "$Header: /home/cvsadm/cvsroot/fermi/servers/replicator/src/Replicator.cpp,v 1.18 2019-05-09 09:42:35 claudio Exp $";
//+=============================================================================
//
// file :         Replicator.cpp
//
// description :  C++ source for the Replicator and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                Replicator are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author: claudio $
//
// $Revision: 1.18 $
//
// $Log: Replicator.cpp,v $
// Revision 1.18  2019-05-09 09:42:35  claudio
// #8723: scrittura bool, lettura/scrittura spctrum of long
//
// Revision 1.17  2019-03-18 16:38:32  claudio
// first successful propagation of ATTR_CONF_EVENT
//
// Revision 1.16  2019-03-12 09:19:56  claudio
// prototype of static full configuration of replicated attributes
//
// Revision 1.15  2018-03-06 11:27:29  claudio
// TANGO_BASE_CLASS
//
// Revision 1.14  2017-09-13 12:06:53  claudio
// memeory leak with strings
//
// Revision 1.13  2017-09-13 08:53:41  claudio
// compiles with tango-9, 64 biit
//
// Revision 1.12  2016-05-04 08:33:13  claudio
// tang9/device_5Impl
//
// Revision 1.11  2014-05-22 09:44:49  claudio
// added catch(...) {...mutex->unlock();...}
//
// Revision 1.10  2014-03-25 12:47:46  claudio
// forec transparency_reconnection to DeviceProxy and AttributeProxies
//
// Revision 1.9  2013-12-05 15:30:48  claudio
// corrected wrong list size checks
// use AttributeProxy::name() intead of calling get_attribute_config on remote device
// exploit copy operator for swapping AttributeName lists
//
// Revision 1.8  2013-10-28 09:33:24  claudio
// TANGO_BASE_CLASS
//
// Revision 1.7  2013-10-24 10:35:09  claudio
// corrected bug: unlock mutex before re_throwing exception
//
// Revision 1.6  2013-10-24 07:42:35  claudio
// addes re-throwing of tango excetions for read_attribute, write_attribute,command_inout in orderd to behave as the native interface
//
// Revision 1.5  2011/03/31 14:45:05  mdm
// Removed ping
//
// Revision 1.2  2010/08/04 15:15:51  mdm
// Map cleanup
//
// Revision 1.1.1.1  2009/12/09 13:24:29  mdm
// first import
//
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================

//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name    |  Method name
//	----------------------------------------
//  State           |  dev_state()
//  Status          |  dev_status()
//  GenericCommand  |  generic_command()
//
//===================================================================

#include <tango.h>
#include <Replicator.h>
#include <ReplicatorClass.h>
#include <vector>
#include <ReplicatorUtils.h>

namespace Replicator_ns {

//+----------------------------------------------------------------------------
//
// method : 		Replicator::Replicator(string &s)
//
// description : 	constructor for simulated Replicator
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name
//
//-----------------------------------------------------------------------------
Replicator::Replicator(Tango::DeviceClass *cl, string &s) :
                TANGO_BASE_CLASS(cl,s.c_str())
{
    init_device();
}

Replicator::Replicator(Tango::DeviceClass *cl, const char *s) :
                TANGO_BASE_CLASS(cl,s)
{
    init_device();
}

Replicator::Replicator(Tango::DeviceClass *cl, const char *s, const char *d) :
                TANGO_BASE_CLASS(cl,s,d)
{
    init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		Replicator::delete_device()
//
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void Replicator::delete_device() {
    DEBUG_STREAM << "Start deleting" << endl;
    //	Delete device's allocated object

    //unsubscribe events first
    vector<int>::iterator iditer;
    for (iditer = event_id.begin(); iditer < event_id.end(); iditer++) {
        replicatorProxy->unsubscribe_event(*iditer);

    }
    event_id.clear();

    if (attributeInfoListEx) {
        delete attributeInfoListEx;
        attributeInfoListEx = 0;
    }
    if (commandInfoList) {
        delete commandInfoList;
        commandInfoList = 0;
    }
    if (replicatorProxy) {
        delete replicatorProxy;
        replicatorProxy = 0;
    }
    if (mutex) {
        delete mutex;
        mutex = 0;
    }
    if (rState) {
        delete rState;
        rState = 0;
    }

    DEBUG_STREAM << "Deleting attribute list" << endl;
    freeAllDevTypeMap();
    delete confcb;
}

//+----------------------------------------------------------------------------
//
// method : 		Replicator::init_device()
//
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void Replicator::init_device() {
    INFO_STREAM << "Replicator::Replicator() create device " << deviceToReplicate << endl;

    // Initialise variables to default values
    //--------------------------------------------
    get_device_property();

    mutex = new omni_mutex();

    rState = new Tango::DevState();
    *rState = Tango::INIT;
    CORBA::string_free(rStatus);
    rStatus = CORBA::string_dup("init");

    //freeAllDevTypeMap();

    //create callback for AttrConfChangeEvent
    event_id.clear(); //for safety...
    confcb = new AttrConfCallBack(this);

    try {
        INFO_STREAM << "Replicator try to connect with: " << deviceToReplicate << endl;
        //device proxy for the replicated device
        replicatorProxy = new Tango::DeviceProxy(deviceToReplicate);
        replicatorProxy->set_transparency_reconnection(true);

        set_state(Tango::RUNNING);
        //set_status(" Connection established ");
        INFO_STREAM << "Replicator connection established with: " << deviceToReplicate << endl;

        std::vector<std::string> attributeNameList = *replicatorProxy->get_attribute_list();

        bool attrFound = false;
        std::vector<std::string> tmpAttributeNameList; // = new std::vector<std::string>();

        DEBUG_STREAM << "Attribute list size: " << attributeList.size() << endl;

        if (attributeList.size() > 0) {
            INFO_STREAM << "Removing attribute from attribute list: " << endl;
            for (unsigned int i = 0; i < attributeNameList.size(); i++) {
                attrFound = false;
                DEBUG_STREAM << "Looking for " << (attributeNameList)[i] << ": " << endl;
                for (unsigned int j = 0; j < attributeList.size(); j++) {
                    DEBUG_STREAM << " - " << attributeList[j] << endl;
                    if (((attributeNameList)[i]) == (attributeList[j])) {
                        DEBUG_STREAM << "found! " << endl;
                        attrFound = true;
                        tmpAttributeNameList.push_back((attributeNameList)[i]);
                        continue;
                    }
                }
                if (!attrFound) {
                    DEBUG_STREAM << "not found, removing... " << endl;
                }
            }
            //delete attributeNameList;
            attributeNameList = tmpAttributeNameList;
            //tmpAttributeNameList = 0;
        }

        if (attributeNameList.size() == 0) {
            *rState = Tango::FAULT;
            //rStatusStr = "Replicator: attribute list cannot be empty!";
            CORBA::string_free(rStatus);
            rStatus = CORBA::string_dup("Replicator: attribute list cannot be empty!");
            DEBUG_STREAM << "Replicator: attribute list cannot be empty!" << endl;
        }

        attributeInfoListEx = replicatorProxy->get_attribute_config_ex(attributeNameList);

        commandInfoList = replicatorProxy->command_list_query();

        for (unsigned int i = 0; i < attributeInfoListEx->size(); i++) {
            string attributeName = (*attributeInfoListEx)[i].name;
            int data_type = (*attributeInfoListEx)[i].data_type;
            int maxDimX = (*attributeInfoListEx)[i].max_dim_x;
            int maxDimY = (*attributeInfoListEx)[i].max_dim_y;
            Tango::AttrWriteType writable = (*attributeInfoListEx)[i].writable;
            std::string writable_attr_name = (*attributeInfoListEx)[i].writable_attr_name;

            INFO_STREAM << "Importing  " << deviceToReplicate << "/" << attributeName << " attribute " << endl;
            DEBUG_STREAM << "   data type:  " << data_type << endl;
            DEBUG_STREAM << "   writable:  " << writable << endl;
            DEBUG_STREAM << "   x: " << maxDimX << endl;
            DEBUG_STREAM << "   y: " << maxDimY << endl;
            DEBUG_STREAM << "   writable name: " << writable_attr_name << endl;

            if (attributeName == "Status" || attributeName == "State") {
                DEBUG_STREAM << "Skipping " << attributeName << endl;
                continue;
            }

            try {
                if (maxDimX == 1 && maxDimY == 0) {
                    DEBUG_STREAM << "Scalar attribute instance created. " << endl;
                    GenericScalarAttrib* attrInstance = new GenericScalarAttrib(attributeName.c_str(), data_type, writable,
                            writable_attr_name.c_str(), (*attributeInfoListEx)[i]);
                    add_attribute(attrInstance); //attenzione aggiunga alla Class , non al Device
                    event_id.push_back(replicatorProxy->subscribe_event(attributeName, Tango::ATTR_CONF_EVENT, confcb));
                    DEBUG_STREAM << __LINE__  << " subscribe_event " << attributeName << endl;
                } else if (maxDimX >= 1 && maxDimY == 0) {
                    DEBUG_STREAM << "Spectrum attribute instance created. " << endl;
                    GenericSpectrumAttrib* attrInstance = new GenericSpectrumAttrib(attributeName.c_str(), data_type, writable,
                            maxDimX, (*attributeInfoListEx)[i]);
                    add_attribute(attrInstance); //attenzione aggiunga alla Class , non al Device
                    event_id.push_back(replicatorProxy->subscribe_event(attributeName, Tango::ATTR_CONF_EVENT, confcb));
                    DEBUG_STREAM << __LINE__  << " subscribe_event " << attributeName << endl;
                } else {
                    DEBUG_STREAM << "Image attribute instance created. " << attributeName << endl;
                    GenericImageAttrib* attrInstance = new GenericImageAttrib(attributeName.c_str(), data_type, writable, maxDimX,
                            maxDimY, (*attributeInfoListEx)[i]);
                    add_attribute(attrInstance);
                    event_id.push_back(replicatorProxy->subscribe_event(attributeName, Tango::ATTR_CONF_EVENT, confcb));
                    DEBUG_STREAM << __LINE__  << " subscribe_event " << attributeName << endl;
                }

                addToDevTypeMap(attributeName, data_type, maxDimX, maxDimY);

                if (writable != 0) // writable==0 -> Read only
                {
                    addToDevTypeMapWrite(attributeName, data_type, maxDimX, maxDimY);
                }
                //TODO: set default properties also for read-only attributes
                Tango::AttributeProxy* attrProxyInstance = new Tango::AttributeProxy(replicatorProxy, attributeName);
                attrProxyInstance->set_transparency_reconnection(true);
                attrProxyInstance->set_config((*attributeInfoListEx)[i]);
                attributeProxyList.push_back(attrProxyInstance);
            } catch (Tango::DevFailed e) {
                WARN_STREAM << "Fail to import " << deviceToReplicate << "/" << attributeName << " attribute " << endl;
            }

            DEBUG_STREAM << deviceToReplicate << "/" << attributeName << " attribute imported" << endl;
        }

        bool cmdFound = false;
        Tango::CommandInfoList* tmpCommandInfoList = new Tango::CommandInfoList();

        DEBUG_STREAM << "Command list size: " << commandList.size() << endl;

        if (commandList.size() > 0) {
            INFO_STREAM << "Removing command from command list:" << endl;
            for (unsigned int i = 0; i < commandInfoList->size(); i++) {
                cmdFound = false;
                DEBUG_STREAM << "Looking for: " << (*commandInfoList)[i].cmd_name << ": " << endl;
                for (unsigned int j = 0; j < commandList.size(); j++) {
                    DEBUG_STREAM << " - " << commandList[j] << endl;
                    if (commandList[j] == (*commandInfoList)[i].cmd_name) {
                        DEBUG_STREAM << "found! " << endl;
                        cmdFound = true;
                        tmpCommandInfoList->push_back((*commandInfoList)[i]);
                        continue;
                    }
                }
                if (!cmdFound) {
                    DEBUG_STREAM << "not found, removing... " << endl;
                }
            }
            delete commandInfoList;
            commandInfoList = tmpCommandInfoList;
            tmpCommandInfoList = 0;
        }

        std::vector<Tango::CommandInfo>::iterator cmdIt;
        for (cmdIt = commandInfoList->begin(); cmdIt < commandInfoList->end(); cmdIt++) {
            string cmd_name = cmdIt->cmd_name;
            long in_type = cmdIt->in_type;
            long out_type = cmdIt->out_type;
            string in_type_desc = cmdIt->in_type_desc;
            string out_type_desc = cmdIt->out_type_desc;
            Tango::DispLevel disp_level = cmdIt->disp_level;

            INFO_STREAM << "Importing  " << deviceToReplicate << "/" << cmd_name << " command " << endl;
            DEBUG_STREAM << "   in type: " << in_type << endl;
            DEBUG_STREAM << "   out type: " << out_type << endl;
            DEBUG_STREAM << "   in type description: " << out_type_desc << endl;
            DEBUG_STREAM << "   out type description: " << out_type_desc << endl;
            DEBUG_STREAM << "   display level: " << disp_level << endl;

            try {
                GenericCommandClass* cmdInstance = new GenericCommandClass(cmd_name, static_cast<Tango::CmdArgType>(in_type),
                        static_cast<Tango::CmdArgType>(out_type));
                add_command(cmdInstance);
            } catch (Tango::DevFailed e) {
                WARN_STREAM << "Fail to import " << deviceToReplicate << "/" << cmd_name << " attribute " << endl;
            }
        }

    }

    catch (Tango::DevFailed &e) {
        *rState = Tango::FAULT;
        CORBA::string_free(rStatus);
        rStatus = CORBA::string_dup("Replicator: init error");

        WARN_STREAM << "Replicator: init error " << endl;
    }
    *rState = Tango::ON;
    CORBA::string_free(rStatus);
    rStatus = CORBA::string_dup("on");
}

//+----------------------------------------------------------------------------
//
// method : 		Replicator::get_device_property()
//
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void Replicator::get_device_property() {
    //	Initialize your default values here (if not done with  POGO).
    //------------------------------------------------------------------

    //	Read device properties from database.(Automatic code generation)
    //------------------------------------------------------------------
    Tango::DbData dev_prop;
    dev_prop.push_back(Tango::DbDatum("AttributeList"));
    dev_prop.push_back(Tango::DbDatum("CommandList"));
    dev_prop.push_back(Tango::DbDatum("DeviceToReplicate"));

    //	Call database and extract values
    //--------------------------------------------
    if (Tango::Util::instance()->_UseDb == true)
        get_db_device()->get_property(dev_prop);
    Tango::DbDatum def_prop, cl_prop;
    ReplicatorClass *ds_class = (static_cast<ReplicatorClass *>(get_device_class()));
    int i = -1;

    //	Try to initialize AttributeList from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty() == false)
        cl_prop >> attributeList;
    else {
        //	Try to initialize AttributeList from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty() == false)
            def_prop >> attributeList;
    }
    //	And try to extract AttributeList value from database
    if (dev_prop[i].is_empty() == false)
        dev_prop[i] >> attributeList;

    //	Try to initialize CommandList from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty() == false)
        cl_prop >> commandList;
    else {
        //	Try to initialize CommandList from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty() == false)
            def_prop >> commandList;
    }
    //	And try to extract CommandList value from database
    if (dev_prop[i].is_empty() == false)
        dev_prop[i] >> commandList;

    //	Try to initialize DeviceToReplicate from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty() == false)
        cl_prop >> deviceToReplicate;
    else {
        //	Try to initialize DeviceToReplicate from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty() == false)
            def_prop >> deviceToReplicate;
    }
    //	And try to extract DeviceToReplicate value from database
    if (dev_prop[i].is_empty() == false)
        dev_prop[i] >> deviceToReplicate;

    //	End of Automatic code generation
    //------------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//
// method : 		Replicator::always_executed_hook()
//
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void Replicator::always_executed_hook() {
}
//+----------------------------------------------------------------------------
//
// method : 		Replicator::read_attr_hardware
//
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void Replicator::read_attr_hardware(vector<long> &attr_list) {
    DEBUG_STREAM << "Replicator::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
    //	Add your own code here
}

//+----------------------------------------------------------------------------
//
// method : 		Replicator::read_GenericScalar
//
// description : 	Extract real attribute values for GenericScalar acquisition result.
//
//-----------------------------------------------------------------------------
void Replicator::read_GenericAttribute(Tango::Attribute &attr) {
    DEBUG_STREAM << "Replicator::read_GenericAttribute(Tango::Attribute &attr) entering... " << endl;

    mutex->lock();
    DEBUG_STREAM << "	Mutex locked" << endl;

    string attrName = attr.get_name();
    int data_type = attr.get_data_type();
    int maxDimX = attr.get_max_dim_x();
    int maxDimY = attr.get_max_dim_y();
    int dimX = attr.get_x();
    int dimY = attr.get_y();

    DEBUG_STREAM << "	Request for attribute: " << attrName << " type: " << data_type << endl;
    DEBUG_STREAM << " 	X: " << dimX << " max X: " << maxDimX << endl;
    DEBUG_STREAM << " 	Y: " << dimY << " max Y: " << maxDimY << endl;
    DEBUG_STREAM << "	data size: " << attr.get_data_size() << endl;

    for (unsigned int i = 0; i < attributeProxyList.size(); i++) {

        if ((attributeProxyList[i])->name() == attrName) {
            try {
                DEBUG_STREAM << "	Use proxy: " << (attributeProxyList[i])->name() << endl;
                Tango::DeviceAttribute dAttr = (attributeProxyList[i])->read();
                switch (data_type) {
                case Tango::DEV_BOOLEAN:
                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr >> *(devBooleanList[attrName]);
                        attr.set_value(devBooleanList[attrName]);
                    } else {
                        std::vector<Tango::DevBoolean> bool_vector;
                        dAttr >> bool_vector;
                        unsigned int rsize;
                        if (attr.get_writable()!=0)
                            rsize = bool_vector.size()/2;
                        else
                            rsize = bool_vector.size();
                        for (unsigned int j = 0; j < rsize; j++) {
                            (devBooleanList[attrName])[j] = bool_vector[j];
                        }
                        attr.set_value(devBooleanList[attrName], rsize, maxDimY, false);
                    }
                    break;

                case Tango::DEV_UCHAR:

                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr >> *(devUCharList[attrName]);
                        attr.set_value(devUCharList[attrName]);
                    } else {
                        std::vector<Tango::DevUChar> uchar_vector;
                        dAttr >> uchar_vector;
                        unsigned int rsize;
                        if (attr.get_writable()!=0)
                            rsize = uchar_vector.size()/2;
                        else
                            rsize = uchar_vector.size();
                        for (unsigned int j = 0; j < rsize; j++) {
                            (devUCharList[attrName])[j] = uchar_vector[j];
                        }
                        attr.set_value(devUCharList[attrName], rsize, maxDimY, false);
                    }
                    break;

                case Tango::DEV_SHORT:
                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr >> *(devShortList[attrName]);
                        attr.set_value(devShortList[attrName]);
                    } else {
                        std::vector<Tango::DevShort> short_vector;
                        dAttr >> short_vector;
                        unsigned int rsize;
                        if (attr.get_writable()!=0)
                            rsize = short_vector.size()/2;
                        else
                            rsize = short_vector.size();
                        for (unsigned int j = 0; j < rsize; j++) {
                            (devShortList[attrName])[j] = short_vector[j];
                        }
                        attr.set_value(devShortList[attrName], rsize, maxDimY, false);
                    }
                    break;

                case Tango::DEV_USHORT:
                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr >> *(devUShortList[attrName]);
                        attr.set_value(devUShortList[attrName]);
                    } else {
                        std::vector<Tango::DevUShort> ushort_vector;
                        dAttr >> ushort_vector;
                        unsigned int rsize;
                        if (attr.get_writable()!=0)
                            rsize = ushort_vector.size()/2;
                        else
                            rsize = ushort_vector.size();
                        for (unsigned int j = 0; j < rsize; j++) {
                            (devUShortList[attrName])[j] = ushort_vector[j];
                        }
                        attr.set_value(devUShortList[attrName], rsize, maxDimY, false);
                    }
                    break;

                case Tango::DEV_LONG:
                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr >> *(devLongList[attrName]);
                        attr.set_value(devLongList[attrName]);
                    } else {
                        std::vector<Tango::DevLong> long_vector;
                        dAttr >> long_vector;
                        unsigned int rsize;
                        if (attr.get_writable()!=0)
                            rsize = long_vector.size()/2;
                        else
                            rsize = long_vector.size();

                        DEBUG_STREAM << "long vector size:" << long_vector.size() << " " << maxDimX ;
                        for (unsigned int j = 0; j < rsize; j++) {
                            (devLongList[attrName])[j] = long_vector[j];
                        }
                        attr.set_value(devLongList[attrName], rsize, maxDimY, false);
                    }
                    break;

                case Tango::DEV_ULONG:
                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr >> *(devULongList[attrName]);
                        attr.set_value(devULongList[attrName]);
                    } else {
                        std::vector<Tango::DevULong> ul_vector;
                        dAttr >> ul_vector;
                        unsigned int rsize;
                        if (attr.get_writable()!=0)
                            rsize = ul_vector.size()/2;
                        else
                            rsize = ul_vector.size();
                        for (unsigned int j = 0; j < rsize; j++) {
                            (devULongList[attrName])[j] = ul_vector[j];
                        }
                        attr.set_value(devULongList[attrName], rsize, maxDimY, false);
                    }
                    break;

                case Tango::DEV_LONG64:
                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr >> *(devLong64List[attrName]);
                        attr.set_value(devLong64List[attrName]);
                    } else {
                        std::vector<Tango::DevLong64> ll_vector;
                        dAttr >> ll_vector;
                        unsigned int rsize;
                        if (attr.get_writable()!=0)
                            rsize = ll_vector.size()/2;
                        else
                            rsize = ll_vector.size();
                        for (unsigned int j = 0; j < rsize; j++) {
                            (devLong64List[attrName])[j] = ll_vector[j];
                        }
                        attr.set_value(devLong64List[attrName], rsize, maxDimY, false);
                    }
                    break;

                case Tango::DEV_ULONG64:
                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr >> *(devULong64List[attrName]);
                        attr.set_value(devULong64List[attrName]);
                    } else {
                        std::vector<Tango::DevULong64> ull_vector;
                        dAttr >> ull_vector;
                        unsigned int rsize;
                        if (attr.get_writable()!=0)
                            rsize = ull_vector.size()/2;
                        else
                            rsize = ull_vector.size();
                        for (unsigned int j = 0; j < rsize; j++) {
                            (devULong64List[attrName])[j] = ull_vector[j];
                        }
                        attr.set_value(devULong64List[attrName], rsize, maxDimY, false);
                    }
                    break;

                case Tango::DEV_FLOAT:
                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr >> *(devFloatList[attrName]);
                        attr.set_value(devFloatList[attrName]);
                    } else {
                        std::vector<Tango::DevFloat> float_vector;
                        dAttr >> float_vector;
                        unsigned int rsize;
                        if (attr.get_writable()!=0)
                            rsize = float_vector.size()/2;
                        else
                            rsize = float_vector.size();
                        for (unsigned int j = 0; j < rsize; j++) {
                            (devFloatList[attrName])[j] = float_vector[j];
                        }
                        attr.set_value(devFloatList[attrName], rsize, maxDimY, false);
                    }
                    break;

                case Tango::DEV_DOUBLE:
                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr >> *(devDoubleList[attrName]);
                        attr.set_value(devDoubleList[attrName]);
                    } else {
                        std::vector<Tango::DevDouble> double_vector;
                        dAttr >> double_vector;
                        unsigned int rsize;
                        if (attr.get_writable()!=0)
                            rsize = double_vector.size()/2;
                        else
                            rsize = double_vector.size();
                        for (unsigned int j = 0; j < rsize; j++) {
                            (devDoubleList[attrName])[j] = double_vector[j];
                        }
                        attr.set_value(devDoubleList[attrName], rsize, maxDimY, false);
                    }
                    break;

                case Tango::DEV_STRING:
                    if (maxDimX == 1 && maxDimY == 0) {
                        std::string tmp_str;
                        dAttr >> tmp_str;
                        CORBA::string_free(*(devStringList[attrName]));
                        *(devStringList[attrName]) = CORBA::string_dup(tmp_str.c_str());
                        attr.set_value(devStringList[attrName]);
                    } else {
                        //TODO
                        //Tango::DevVarStringArray tmp_str_arr;
                        vector<string> tmp_str_arr;
                        dAttr >> tmp_str_arr;
                        unsigned int rsize;
                        if (attr.get_writable()!=0)
                            rsize = tmp_str_arr.size()/2;
                        else
                            rsize = tmp_str_arr.size();
                        for (unsigned int j = 0; j < rsize; j++) {
                            CORBA::string_free((devStringList[attrName])[j]);
                            (devStringList[attrName])[j] = CORBA::string_dup(tmp_str_arr[j].c_str());
                        }
                        attr.set_value(devStringList[attrName], rsize, maxDimY, false);
                    }
                    break;

                case Tango::DEV_STATE:
                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr >> *(devStateList[attrName]);
                        attr.set_value(devStateList[attrName]);
                    } else {
                        //TODO
                        WARN_STREAM << "Error: " << endl;
                    }
                    break;
                }

            } catch (Tango::DevFailed &e) {
                WARN_STREAM << "Error: " << e << endl;
                mutex->unlock();
                DEBUG_STREAM << "	Mutex unlocked in catch(Tango::DevFailed)" << endl;
                Tango::Except::re_throw_exception(e, "TANGO error", "replicator error", "read attribute", Tango::ERR);
            } catch (...) {
                WARN_STREAM << "Generic Error" << endl;
                mutex->unlock();
                DEBUG_STREAM << "	Mutex unlocked in catch(...)" << endl;
                Tango::Except::throw_exception("error", "replicator error", "read attribute", Tango::ERR);
            }
        }
    }

    mutex->unlock();
    DEBUG_STREAM << "	Mutex unlocked" << endl;

}

//+----------------------------------------------------------------------------
//
// method : 		Replicator::write_GenericScalar
//
//
// description : 	Write GenericScalar attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Replicator::write_GenericAttribute(Tango::WAttribute &attr) {

    DEBUG_STREAM << "Replicator::write_GenericAttribute(Tango::Attribute &attr) entering... " << endl;

    mutex->lock();
    //DEBUG_STREAM << "	Mutex locked" << endl;

    string attrName = attr.get_name();
    int data_type = attr.get_data_type();

    DEBUG_STREAM << "       Request for attribute: " << attrName << " type: " << data_type << endl;
    DEBUG_STREAM << "       X: " << attr.get_x() << " max X: " << attr.get_max_dim_x() << endl;
    DEBUG_STREAM << "       Y: " << attr.get_y() << " max Y: " << attr.get_max_dim_y() << endl;
    DEBUG_STREAM << "      	WX: " << attr.get_w_dim_x() << endl;
    DEBUG_STREAM << "	    WY: " << attr.get_w_dim_y() << endl;

    int maxDimX = attr.get_w_dim_x();
    int maxDimY = attr.get_w_dim_y();

    int len = 0;

    if (maxDimY == 0) {
        len = attr.get_w_dim_x();
    } else {
        len = maxDimX * maxDimY;
    }

    for (unsigned int i = 0; i < attributeProxyList.size(); i++) {
        if ((attributeProxyList[i])->name() == attrName) {
            try {
                DEBUG_STREAM << "Proxy Name " << (attributeProxyList[i])->name() << endl;
                Tango::DeviceAttribute dAttr;
                //TODO use enum CmdArgType labels for clarity
                switch (attr.get_data_type()) {
                case Tango::DEV_BOOLEAN:
                    if (maxDimX == 1 && maxDimY == 0) {
                        attr.get_write_value(*(devBooleanList_write[attrName]));
                        dAttr << *(devBooleanList_write[attrName]);
                    } else {
                        attr.get_write_value(const_cast<const Tango::DevBoolean*&>(devBooleanList_write[attrName]));
                        vector<Tango::DevBoolean> bool_vector;
                        for (int j = 0; j < len; j++) {
                            bool_vector.push_back((devBooleanList_write[attrName])[j]);
                        }
                        dAttr << bool_vector;
                    }
                    break;

                case Tango::DEV_UCHAR:
                    if (maxDimX == 1 && maxDimY == 0) {
                        attr.get_write_value(*(devUCharList_write[attrName]));
                        dAttr << *(devUCharList_write[attrName]);
                    } else {
                        attr.get_write_value(const_cast<const Tango::DevUChar*&>(devUCharList_write[attrName]));
                        vector<Tango::DevUChar> uchar_vector;
                        for (int j = 0; j < len; j++) {
                            uchar_vector.push_back((devUCharList_write[attrName])[j]);
                        }
                        dAttr << uchar_vector;
                    }

                    break;

                case Tango::DEV_SHORT:
                    if (maxDimX == 1 && maxDimY == 0) {
                        attr.get_write_value(*(devShortList_write[attrName]));
                        dAttr << *(devShortList_write[attrName]);
                    } else {
                        attr.get_write_value(const_cast<const Tango::DevShort*&>(devShortList_write[attrName]));
                        vector<Tango::DevShort> short_vector;
                        for (int j = 0; j < len; j++) {
                            short_vector.push_back((devShortList_write[attrName])[j]);
                        }
                        dAttr << short_vector;
                    }
                    break;

                case Tango::DEV_USHORT:
                    if (maxDimX == 1 && maxDimY == 0) {
                        attr.get_write_value(*(devUShortList_write[attrName]));
                        dAttr << *(devUShortList_write[attrName]);
                    } else {
                        attr.get_write_value(const_cast<const Tango::DevUShort*&>(devUShortList_write[attrName]));
                        vector<Tango::DevUShort> ushort_vector;
                        for (int j = 0; j < len; j++) {
                            ushort_vector.push_back((devUShortList_write[attrName])[j]);
                        }
                        dAttr << ushort_vector;
                    }
                    break;

                case Tango::DEV_LONG:
                    if (maxDimX == 1 && maxDimY == 0) {
                        attr.get_write_value(*(devLongList_write[attrName]));
                        dAttr << *(devLongList_write[attrName]);
                    } else {
                        attr.get_write_value(const_cast<const Tango::DevLong*&>(devLongList_write[attrName]));
                        vector<Tango::DevLong> long_vector;
                        for (int j = 0; j < len; j++) {
                            long_vector.push_back((devLongList_write[attrName])[j]);
                        }
                        dAttr << long_vector;
                    }
                    break;

                case Tango::DEV_ULONG:
                    if (maxDimX == 1 && maxDimY == 0) {
                        attr.get_write_value(*(devULongList_write[attrName]));
                        dAttr << *(devULongList_write[attrName]);
                    } else {
                        attr.get_write_value(const_cast<const Tango::DevULong*&>(devULongList_write[attrName]));
                        vector<Tango::DevULong> ul_vector;
                        for (int j = 0; j < len; j++) {
                            ul_vector.push_back((devULongList_write[attrName])[j]);
                        }
                        dAttr << ul_vector;
                    }
                    break;

                case Tango::DEV_LONG64:
                    if (maxDimX == 1 && maxDimY == 0) {
                        attr.get_write_value(*(devLong64List_write[attrName]));
                        dAttr << *(devLong64List_write[attrName]);
                    } else {
                        attr.get_write_value(const_cast<const Tango::DevLong64*&>(devLong64List_write[attrName]));
                        vector<Tango::DevLong64> ll_vector;
                        for (int j = 0; j < len; j++) {
                            ll_vector.push_back((devLong64List_write[attrName])[j]);
                        }
                        dAttr << ll_vector;
                    }
                    break;

                case Tango::DEV_ULONG64:
                    if (maxDimX == 1 && maxDimY == 0) {
                        attr.get_write_value(*(devULong64List_write[attrName]));
                        dAttr << *(devULong64List_write[attrName]);
                    } else {
                        attr.get_write_value(const_cast<const Tango::DevULong64*&>(devULong64List_write[attrName]));
                        vector<Tango::DevULong64> ull_vector;
                        for (int j = 0; j < len; j++) {
                            ull_vector.push_back((devULong64List_write[attrName])[j]);
                        }
                        dAttr << ull_vector;
                    }
                    break;

                case Tango::DEV_FLOAT:
                    if (maxDimX == 1 && maxDimY == 0) {
                        attr.get_write_value(*(devFloatList_write[attrName]));
                        dAttr << *(devFloatList_write[attrName]);
                    } else {
                        attr.get_write_value(const_cast<const Tango::DevFloat*&>(devFloatList_write[attrName]));
                        vector<Tango::DevFloat> float_vector;
                        for (int j = 0; j < len; j++) {
                            float_vector.push_back((devFloatList_write[attrName])[j]);
                        }
                        dAttr << float_vector;
                    }
                    break;

                case Tango::DEV_DOUBLE:
                    if (maxDimX == 1 && maxDimY == 0) {
                        attr.get_write_value(*(devDoubleList_write[attrName]));
                        dAttr << *(devDoubleList_write[attrName]);
                    } else {
                        attr.get_write_value(const_cast<const Tango::DevDouble*&>(devDoubleList_write[attrName]));
                        vector<Tango::DevDouble> double_vector;
                        for (int j = 0; j < len; j++) {
                            double_vector.push_back((devDoubleList_write[attrName])[j]);
                        }
                        dAttr << double_vector;
                    }
                    break;

                case Tango::DEV_STRING:
                    attr.get_write_value(*(devStringList_write[attrName]));
                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr << *(devStringList_write[attrName]);
                    } else {
                        //TODO:
                        WARN_STREAM << "Error: not yet implemented " << endl;
                    }
                    break;

                case Tango::DEV_STATE:
                    attr.get_write_value(*(devStateList_write[attrName]));
                    if (maxDimX == 1 && maxDimY == 0) {
                        dAttr << *(devStateList_write[attrName]);
                    } else {
                        //TODO:
                        WARN_STREAM << "Error: not yet implemented " << endl;
                    }
                    break;
                }
                (attributeProxyList[i])->write(dAttr);

            } catch (Tango::DevFailed &e) {
                WARN_STREAM << "Error: " << e << endl;
                mutex->unlock();
                DEBUG_STREAM << "	Mutex unlocked in catch(Tango::DevFailed)" << endl;
                Tango::Except::re_throw_exception(e, "TANGO error", "replicator error", "write attribute", Tango::ERR);
            } catch (...) {
                WARN_STREAM << "genric Error" << endl;
                mutex->unlock();
                DEBUG_STREAM << "	Mutex unlocked in catch(...)" << endl;
                Tango::Except::throw_exception("Terror", "replicator error", "write attribute", Tango::ERR);
            }

        }
    }

    mutex->unlock();
    DEBUG_STREAM << "	Mutex unlocked" << endl;
}

//+------------------------------------------------------------------
/**
 *	method:	Replicator::dev_state
 *
 *	description:
 *
 *
 */
//+------------------------------------------------------------------
Tango::DevState Replicator::dev_state() {
    return replicatorProxy->state();
}
//+------------------------------------------------------------------
/**
 *	method:	Replicator::dev_status
 *
 *	description:
 *
 *
 */
//+------------------------------------------------------------------
const char*
Replicator::dev_status() {
    return (CORBA::string_dup(replicatorProxy->status().c_str()));
}
//+----------------------------------------------------------------------------
//
// method :             Test::read_RState
//
// description :        Extract real attribute values for RState acquisition result.
//
//-----------------------------------------------------------------------------
void Replicator::read_RState(Tango::Attribute &attr) {
    DEBUG_STREAM << "Test::read_RState(Tango::Attribute &attr) entering... " << endl;
    attr.set_value(rState);
}
//+----------------------------------------------------------------------------
//
// method :             Test::read_RStatus
//
// description :        Extract real attribute values for RStatus acquisition result.
//
//-----------------------------------------------------------------------------
void Replicator::read_RStatus(Tango::Attribute &attr) {
    DEBUG_STREAM << "Test::read_RStatus(Tango::Attribute &attr) entering... " << endl;
    attr.set_value(&rStatus);
}
//+------------------------------------------------------------------
/**
 *	method:	Replicator::generic_command
 *
 *	description:	method to execute "GenericCommand"
 *
 *
 */
//+------------------------------------------------------------------
CORBA::Any*
Replicator::generic_command(std::string cmd_name, Tango::CmdArgType in_type, Tango::CmdArgType out_type, const CORBA::Any &in_any) {

    DEBUG_STREAM << "Replicator::generic_command(): entering... !" << endl;

    mutex->lock();
    DEBUG_STREAM << "	Mutex locked" << endl;

    Tango::DeviceData argin;
    Tango::DeviceData argout;
    CORBA::Any* any = 0;

    if (static_cast<long>(in_type) != 0) //if 0 -> void argin
    {
        argin = ReplicatorUtils::fromCorbaAnyToDeviceData(in_any, in_type);
    }

    try {
        if (static_cast<long>(in_type) != 0) {
            DEBUG_STREAM << "	Executing: " << cmd_name << " command  with argin " << endl;

            argout = replicatorProxy->command_inout(cmd_name, argin);
        } else {
            DEBUG_STREAM << "	Executing: " << cmd_name << " command " << endl;

            argout = replicatorProxy->command_inout(cmd_name);
        }
    } catch (Tango::DevFailed &e) {
        WARN_STREAM << "	Error executing " << cmd_name << " command " << endl;
        WARN_STREAM << e << endl;
        mutex->unlock();
        Tango::Except::re_throw_exception(e, "TANGO error", "replicator error", "command_inout", Tango::ERR);
    } catch (...) {
        WARN_STREAM << "	Error executing " << cmd_name << " command " << endl;
        mutex->unlock();
        Tango::Except::throw_exception("error", "replicator error", "command_inout", Tango::ERR);
    }

    mutex->unlock();
    DEBUG_STREAM << "	Mutex unlocked" << endl;

    if (static_cast<long>(out_type) != 0) // f 0 -> void argout
    {
        DEBUG_STREAM << "	Returning value" << endl;

        any = ReplicatorUtils::fromDeviceDataToCorbaAny(argout, out_type);

        return any;
    } else {
        DEBUG_STREAM << "	Returning void" << endl;

        return new CORBA::Any();
    }
}

//+------------------------------------------------------------------
/**
 *      method: Replicator::add_command
 *
 *      description:
 *
 *
 */
//+------------------------------------------------------------------
void Replicator::add_command(Tango::Command *new_cmd) {

    DEBUG_STREAM << "Replicator::add_command(): entering... !" << endl;
    vector<Tango::Command *> &cmd_list = device_class->get_command_list();

    bool found = false;

    for (unsigned int i = 0; i < cmd_list.size(); i++) {
        if (cmd_list[i]->get_name() == new_cmd->get_name()) {
            INFO_STREAM << "	" << new_cmd->get_name() << " already in command list " << endl;
            INFO_STREAM << "	Skipping insertion " << endl;

            //throw new Tango::DevFailed();

            found = true;
            break;
        }
    }

    if (!found) {
        cmd_list.push_back(new_cmd);
        INFO_STREAM << "	Command " << new_cmd->get_name() << " inserted in command list" << endl;
    }

}

//+------------------------------------------------------------------
/**
 *      method: Replicator::addToDevTypeMap
 *
 *      description:
 *
 *
 */
//+------------------------------------------------------------------
void Replicator::addToDevTypeMap(string name, int data_type, int maxDimX, int maxDimY) {

    DEBUG_STREAM << "Replicator::addToDevMap(): entering... !" << endl;
    DEBUG_STREAM << "name: " << name << endl;
    DEBUG_STREAM << "data_type: " << data_type << endl;
    DEBUG_STREAM << "maxDimX: " << maxDimX << endl;
    DEBUG_STREAM << "maxDimY: " << maxDimY << endl;

    int len = 0;

    if (maxDimY == 0) {
        len = maxDimX;
    } else {
        len = maxDimX * maxDimY;
    }

    switch (data_type) {
    case 1:
        if (maxDimX == 1 && maxDimY == 0) {
            devBooleanList.insert(std::pair<string, Tango::DevBoolean*>(name, new Tango::DevBoolean()));
        } else {
            devBooleanList.insert(std::pair<string, Tango::DevBoolean*>(name, new Tango::DevBoolean[len]));
            memset(devBooleanList[name], 0, len * sizeof(Tango::DevBoolean));
        }
        break;

    case 22:
        if (maxDimX == 1 && maxDimY == 0) {
            devUCharList.insert(std::pair<string, Tango::DevUChar*>(name, new Tango::DevUChar()));
        } else {
            devUCharList.insert(std::pair<string, Tango::DevUChar*>(name, new Tango::DevUChar[len]));
            memset(devUCharList[name], 0, len * sizeof(Tango::DevUChar));
        }
        break;

    case 2:
        if (maxDimX == 1 && maxDimY == 0) {
            devShortList.insert(std::pair<string, Tango::DevShort*>(name, new Tango::DevShort()));
        } else {
            devShortList.insert(std::pair<string, Tango::DevShort*>(name, new Tango::DevShort[len]));
            memset(devShortList[name], 0, len * sizeof(Tango::DevShort));
        }
        break;

    case 6:
        if (maxDimX == 1 && maxDimY == 0) {
            devUShortList.insert(std::pair<string, Tango::DevUShort*>(name, new Tango::DevUShort()));
        } else {
            devUShortList.insert(std::pair<string, Tango::DevUShort*>(name, new Tango::DevUShort[len]));
            memset(devUShortList[name], 0, len * sizeof(Tango::DevUShort));
        }
        break;

    case 3:
        if (maxDimX == 1 && maxDimY == 0) {
            devLongList.insert(std::pair<string, Tango::DevLong*>(name, new Tango::DevLong()));
        } else {
            devLongList.insert(std::pair<string, Tango::DevLong*>(name, new Tango::DevLong[len]));
            memset(devLongList[name], 0, len * sizeof(Tango::DevLong));
        }
        break;

    case 7:
        if (maxDimX == 1 && maxDimY == 0) {
            devULongList.insert(std::pair<string, Tango::DevULong*>(name, new Tango::DevULong()));
        } else {
            devULongList.insert(std::pair<string, Tango::DevULong*>(name, new Tango::DevULong[len]));
            memset(devULongList[name], 0, len * sizeof(Tango::DevULong));
        }
        break;

    case 23:
        if (maxDimX == 1 && maxDimY == 0) {
            devLong64List.insert(std::pair<string, Tango::DevLong64*>(name, new Tango::DevLong64()));
        } else {
            devLong64List.insert(std::pair<string, Tango::DevLong64*>(name, new Tango::DevLong64[len]));
            memset(devLong64List[name], 0, len * sizeof(Tango::DevLong64));
        }
        break;

    case 24:
        if (maxDimX == 1 && maxDimY == 0) {
            devULong64List.insert(std::pair<string, Tango::DevULong64*>(name, new Tango::DevULong64()));
        } else {
            devULong64List.insert(std::pair<string, Tango::DevULong64*>(name, new Tango::DevULong64[len]));
            memset(devULong64List[name], 0, len * sizeof(Tango::DevULong64));
        }
        break;

    case 4:
        if (maxDimX == 1 && maxDimY == 0) {
            devFloatList.insert(std::pair<string, Tango::DevFloat*>(name, new Tango::DevFloat()));
        } else {
            devFloatList.insert(std::pair<string, Tango::DevFloat*>(name, new Tango::DevFloat[len]));
            memset(devFloatList[name], 0, len * sizeof(Tango::DevFloat));
        }
        break;

    case 5:
        if (maxDimX == 1 && maxDimY == 0) {
            devDoubleList.insert(std::pair<string, Tango::DevDouble*>(name, new Tango::DevDouble()));
        } else {
            devDoubleList.insert(std::pair<string, Tango::DevDouble*>(name, new Tango::DevDouble[len]));
            memset(devDoubleList[name], 0, len * sizeof(Tango::DevDouble));
        }
        break;

    case 8:
        if (maxDimX == 1 && maxDimY == 0) {
            devStringList.insert(std::pair<string, Tango::DevString*>(name, new Tango::DevString()));
        } else {
            devStringList.insert(std::pair<string, Tango::DevString*>(name, new Tango::DevString[len]));
            memset(devStringList[name], 0, len * sizeof(Tango::DevString));
        }
        break;

    case 19:
        if (maxDimX == 1 && maxDimY == 0) {
            devStateList.insert(std::pair<string, Tango::DevState*>(name, new Tango::DevState()));
        } else {
            devStateList.insert(std::pair<string, Tango::DevState*>(name, new Tango::DevState[len]));
            memset(devStateList[name], 0, len * sizeof(Tango::DevState));
        }
        break;
    }
}

//+------------------------------------------------------------------
/**
 *      method: Replicator::addToDevTypeMap
 *
 *      description:
 *
 *
 */
//+------------------------------------------------------------------
void Replicator::addToDevTypeMapWrite(string name, int data_type, int maxDimX, int maxDimY) {

    DEBUG_STREAM << "Replicator::addToDevMapWrite(): entering... !" << endl;
    DEBUG_STREAM << "name: " << name << endl;
    DEBUG_STREAM << "data_type: " << data_type << endl;
    DEBUG_STREAM << "maxDimX: " << maxDimX << endl;
    DEBUG_STREAM << "maxDimY: " << maxDimY << endl;

    int len = 0;

    if (maxDimY == 0) {
        len = maxDimX;
    } else {
        len = maxDimX * maxDimY;
    }

    switch (data_type) {
    case 1:
        if (maxDimX == 1 && maxDimY == 0) {
            devBooleanList_write.insert(std::pair<string, Tango::DevBoolean*>(name, new Tango::DevBoolean()));
        } else {
            devBooleanList_write.insert(std::pair<string, Tango::DevBoolean*>(name, new Tango::DevBoolean[len]));
            memset((void*) devBooleanList_write[name], 0, len * sizeof(Tango::DevBoolean));
        }
        break;

    case 22:
        if (maxDimX == 1 && maxDimY == 0) {
            devUCharList_write.insert(std::pair<string, Tango::DevUChar*>(name, new Tango::DevUChar()));
        } else {
            devUCharList_write.insert(std::pair<string, Tango::DevUChar*>(name, new Tango::DevUChar[len]));
            memset((void*) devUCharList_write[name], 0, len * sizeof(Tango::DevUChar));
        }
        break;

    case 2:
        if (maxDimX == 1 && maxDimY == 0) {
            devShortList_write.insert(std::pair<string, Tango::DevShort*>(name, new Tango::DevShort()));
        } else {
            devShortList_write.insert(std::pair<string, Tango::DevShort*>(name, new Tango::DevShort[len]));
            memset((void*) devShortList_write[name], 0, len * sizeof(Tango::DevShort));
        }
        break;

    case 6:
        if (maxDimX == 1 && maxDimY == 0) {
            devUShortList_write.insert(std::pair<string, Tango::DevUShort*>(name, new Tango::DevUShort()));
        } else {
            devUShortList_write.insert(std::pair<string, Tango::DevUShort*>(name, new Tango::DevUShort[len]));
            memset((void*) devUShortList_write[name], 0, len * sizeof(Tango::DevUShort));
        }
        break;

    case 3:
        if (maxDimX == 1 && maxDimY == 0) {
            devLongList_write.insert(std::pair<string, Tango::DevLong*>(name, new Tango::DevLong()));
        } else {
            devLongList_write.insert(std::pair<string, Tango::DevLong*>(name, new Tango::DevLong[len]));
            memset((void*) devLongList_write[name], 0, len * sizeof(Tango::DevLong));
        }
        break;

    case 7:
        if (maxDimX == 1 && maxDimY == 0) {
            devULongList_write.insert(std::pair<string, Tango::DevULong*>(name, new Tango::DevULong()));
        } else {
            devULongList_write.insert(std::pair<string, Tango::DevULong*>(name, new Tango::DevULong[len]));
            memset((void*) devULongList_write[name], 0, len * sizeof(Tango::DevULong));
        }
        break;

    case 23:
        if (maxDimX == 1 && maxDimY == 0) {
            devLong64List_write.insert(std::pair<string, Tango::DevLong64*>(name, new Tango::DevLong64()));
        } else {
            devLong64List_write.insert(std::pair<string, Tango::DevLong64*>(name, new Tango::DevLong64[len]));
            memset((void*) devLong64List_write[name], 0, len * sizeof(Tango::DevLong64));
        }
        break;

    case 24:
        if (maxDimX == 1 && maxDimY == 0) {
            devULong64List_write.insert(std::pair<string, Tango::DevULong64*>(name, new Tango::DevULong64()));
        } else {
            devULong64List_write.insert(std::pair<string, Tango::DevULong64*>(name, new Tango::DevULong64[len]));
            memset((void*) devULong64List_write[name], 0, len * sizeof(Tango::DevULong64));
        }
        break;

    case 4:
        if (maxDimX == 1 && maxDimY == 0) {
            devFloatList_write.insert(std::pair<string, Tango::DevFloat*>(name, new Tango::DevFloat()));
        } else {
            devFloatList_write.insert(std::pair<string, Tango::DevFloat*>(name, new Tango::DevFloat[len]));
            memset((void*) devFloatList_write[name], 0, len * sizeof(Tango::DevFloat));
        }
        break;

    case 5:
        if (maxDimX == 1 && maxDimY == 0) {
            devDoubleList_write.insert(std::pair<string, Tango::DevDouble*>(name, new Tango::DevDouble()));
        } else {
            devDoubleList_write.insert(std::pair<string, Tango::DevDouble*>(name, new Tango::DevDouble[len]));
            memset((void*) devDoubleList_write[name], 0, len * sizeof(Tango::DevDouble));
        }
        break;

    case 8:
        if (maxDimX == 1 && maxDimY == 0) {
            devStringList_write.insert(std::pair<string, Tango::DevString*>(name, new Tango::DevString()));
        } else {
            devStringList_write.insert(std::pair<string, Tango::DevString*>(name, new Tango::DevString[len]));
            memset((void*) devStringList_write[name], 0, len * sizeof(Tango::DevString));
        }
        break;

    case 19:
        if (maxDimX == 1 && maxDimY == 0) {
            devStateList_write.insert(std::pair<string, Tango::DevState*>(name, new Tango::DevState()));
        } else {
            devStateList_write.insert(std::pair<string, Tango::DevState*>(name, new Tango::DevState[len]));
            memset((void*) devStateList_write[name], 0, len * sizeof(Tango::DevState));
        }
        break;
    }
}

void Replicator::freeAllDevTypeMap() {
    DEBUG_STREAM << "Replicator::freeAllDevTypeMap(): entering... !" << endl;

    std::map<std::string, Tango::DevBoolean*>::const_iterator devBooleanList_it;
    for (devBooleanList_it = devBooleanList.begin(); devBooleanList_it != devBooleanList.end(); ++devBooleanList_it) {
        DEBUG_STREAM << "DELETE: " << ((*devBooleanList_it).first) << endl;
        delete ((*devBooleanList_it).second);
    }
    devBooleanList.clear();

    std::map<std::string, Tango::DevUChar*>::const_iterator devUCharList_it;
    for (devUCharList_it = devUCharList.begin(); devUCharList_it != devUCharList.end(); ++devUCharList_it) {
        DEBUG_STREAM << "DELETE: " << ((*devUCharList_it).first) << endl;
        delete ((*devUCharList_it).second);
    }
    devUCharList.clear();

    std::map<std::string, Tango::DevShort*>::const_iterator devShortList_it;
    for (devShortList_it = devShortList.begin(); devShortList_it != devShortList.end(); ++devShortList_it) {
        DEBUG_STREAM << "DELETE: " << ((*devShortList_it).first) << endl;
        delete ((*devShortList_it).second);
    }
    devShortList.clear();

    std::map<std::string, Tango::DevUShort*>::const_iterator devUShortList_it;
    for (devUShortList_it = devUShortList.begin(); devUShortList_it != devUShortList.end(); ++devUShortList_it) {
        DEBUG_STREAM << "DELETE: " << ((*devUShortList_it).first) << endl;
        delete ((*devUShortList_it).second);
    }
    devUShortList.clear();

    std::map<std::string, Tango::DevLong*>::const_iterator devLongList_it;
    for (devLongList_it = devLongList.begin(); devLongList_it != devLongList.end(); ++devLongList_it) {
        DEBUG_STREAM << "DELETE: " << ((*devLongList_it).first) << endl;
        delete ((*devLongList_it).second);
    }
    devLongList.clear();

    std::map<std::string, Tango::DevULong*>::const_iterator devULongList_it;
    for (devULongList_it = devULongList.begin(); devULongList_it != devULongList.end(); ++devULongList_it) {
        DEBUG_STREAM << "DELETE: " << ((*devULongList_it).first) << endl;
        delete ((*devULongList_it).second);
    }
    devULongList.clear();

    std::map<std::string, Tango::DevLong64*>::const_iterator devLong64List_it;
    for (devLong64List_it = devLong64List.begin(); devLong64List_it != devLong64List.end(); ++devLong64List_it) {
        DEBUG_STREAM << "DELETE: " << ((*devLong64List_it).first) << endl;
        delete ((*devLong64List_it).second);
    }
    devLong64List.clear();

    std::map<std::string, Tango::DevULong64*>::const_iterator devULong64List_it;
    for (devULong64List_it = devULong64List.begin(); devULong64List_it != devULong64List.end(); ++devULong64List_it) {
        DEBUG_STREAM << "DELETE: " << ((*devULong64List_it).first) << endl;
        delete ((*devULong64List_it).second);
    }
    devULong64List.clear();

    std::map<std::string, Tango::DevFloat*>::const_iterator devFloatList_it;
    for (devFloatList_it = devFloatList.begin(); devFloatList_it != devFloatList.end(); ++devFloatList_it) {
        DEBUG_STREAM << "DELETE: " << ((*devFloatList_it).first) << endl;
        delete ((*devFloatList_it).second);
    }
    devFloatList.clear();

    std::map<std::string, Tango::DevDouble*>::const_iterator devDoubleList_it;
    for (devDoubleList_it = devDoubleList.begin(); devDoubleList_it != devDoubleList.end(); ++devDoubleList_it) {
        DEBUG_STREAM << "DELETE: " << ((*devDoubleList_it).first) << endl;
        delete ((*devDoubleList_it).second);
    }
    devDoubleList.clear();

    std::map<std::string, Tango::DevString*>::const_iterator devStringList_it;
    for (devStringList_it = devStringList.begin(); devStringList_it != devStringList.end(); ++devStringList_it) {
        DEBUG_STREAM << "DELETE: " << ((*devStringList_it).first) << endl;
        delete ((*devStringList_it).second);
    }
    devStringList.clear();

    std::map<std::string, Tango::DevState*>::const_iterator devStateList_it;
    for (devStateList_it = devStateList.begin(); devStateList_it != devStateList.end(); ++devStateList_it) {
        DEBUG_STREAM << "DELETE: " << ((*devStateList_it).first) << endl;
        delete ((*devStateList_it).second);
    }
    devStateList.clear();

    std::map<std::string, Tango::DevBoolean*>::const_iterator devBooleanList_write_it;
    for (devBooleanList_write_it = devBooleanList_write.begin(); devBooleanList_write_it != devBooleanList_write.end();
            ++devBooleanList_write_it) {
        DEBUG_STREAM << "DELETE: " << ((*devBooleanList_write_it).first) << endl;
        delete ((*devBooleanList_write_it).second);
    }
    devBooleanList_write.clear();

    std::map<std::string, Tango::DevUChar*>::const_iterator devUCharList_write_it;
    for (devUCharList_write_it = devUCharList_write.begin(); devUCharList_write_it != devUCharList_write.end();
            ++devUCharList_write_it) {
        DEBUG_STREAM << "DELETE: " << ((*devUCharList_write_it).first) << endl;
        delete ((*devUCharList_write_it).second);
    }
    devUCharList_write.clear();

    std::map<std::string, Tango::DevShort*>::const_iterator devShortList_write_it;
    for (devShortList_write_it = devShortList_write.begin(); devShortList_write_it != devShortList_write.end();
            ++devShortList_write_it) {
        DEBUG_STREAM << "DELETE: " << ((*devShortList_write_it).first) << endl;
        delete ((*devShortList_write_it).second);
    }
    devShortList_write.clear();

    std::map<std::string, Tango::DevUShort*>::const_iterator devUShortList_write_it;
    for (devUShortList_write_it = devUShortList_write.begin(); devUShortList_write_it != devUShortList_write.end();
            ++devUShortList_write_it) {
        DEBUG_STREAM << "DELETE: " << ((*devUShortList_write_it).first) << endl;
        delete ((*devUShortList_write_it).second);
    }
    devUShortList_write.clear();

    std::map<std::string, Tango::DevLong*>::const_iterator devLongList_write_it;
    for (devLongList_write_it = devLongList_write.begin(); devLongList_write_it != devLongList_write.end();
            ++devLongList_write_it) {
        DEBUG_STREAM << "DELETE: " << ((*devLongList_write_it).first) << endl;
        delete ((*devLongList_write_it).second);
    }
    devLongList_write.clear();

    std::map<std::string, Tango::DevULong*>::const_iterator devULongList_write_it;
    for (devULongList_write_it = devULongList_write.begin(); devULongList_write_it != devULongList_write.end();
            ++devULongList_write_it) {
        DEBUG_STREAM << "DELETE: " << ((*devULongList_write_it).first) << endl;
        delete ((*devULongList_write_it).second);
    }
    devULongList_write.clear();

    std::map<std::string, Tango::DevLong64*>::const_iterator devLong64List_write_it;
    for (devLong64List_write_it = devLong64List_write.begin(); devLong64List_write_it != devLong64List_write.end();
            ++devLong64List_write_it) {
        DEBUG_STREAM << "DELETE: " << ((*devLong64List_write_it).first) << endl;
        delete ((*devLong64List_write_it).second);
    }
    devLong64List_write.clear();

    std::map<std::string, Tango::DevULong64*>::const_iterator devULong64List_write_it;
    for (devULong64List_write_it = devULong64List_write.begin(); devULong64List_write_it != devULong64List_write.end();
            ++devULong64List_write_it) {
        DEBUG_STREAM << "DELETE: " << ((*devULong64List_write_it).first) << endl;
        delete ((*devULong64List_write_it).second);
    }
    devULong64List_write.clear();

    std::map<std::string, Tango::DevFloat*>::const_iterator devFloatList_write_it;
    for (devFloatList_write_it = devFloatList_write.begin(); devFloatList_write_it != devFloatList_write.end();
            ++devFloatList_write_it) {
        DEBUG_STREAM << "DELETE: " << ((*devFloatList_write_it).first) << endl;
        delete ((*devFloatList_write_it).second);
    }
    devFloatList_write.clear();

    std::map<std::string, Tango::DevDouble*>::const_iterator devDoubleList_write_it;
    for (devDoubleList_write_it = devDoubleList_write.begin(); devDoubleList_write_it != devDoubleList_write.end();
            ++devDoubleList_write_it) {
        DEBUG_STREAM << "DELETE: " << ((*devDoubleList_write_it).first) << endl;
        delete ((*devDoubleList_write_it).second);
    }
    devDoubleList_write.clear();

    std::map<std::string, Tango::DevString*>::const_iterator devStringList_write_it;
    for (devStringList_write_it = devStringList_write.begin(); devStringList_write_it != devStringList_write.end();
            ++devStringList_write_it) {
        DEBUG_STREAM << "DELETE: " << ((*devStringList_write_it).first) << endl;
        delete ((*devStringList_write_it).second);
    }
    devStringList_write.clear();

    std::map<std::string, Tango::DevState*>::const_iterator devStateList_write_it;
    for (devStateList_write_it = devStateList_write.begin(); devStateList_write_it != devStateList_write.end();
            ++devStateList_write_it) {
        DEBUG_STREAM << "DELETE: " << ((*devStateList_write_it).first) << endl;
        delete ((*devStateList_write_it).second);
    }
    devStateList_write.clear();
}

// callback for handling configuration change events
AttrConfCallBack::AttrConfCallBack(Replicator* repli) :
                 Tango::LogAdapter(repli), replicator(repli){
}
AttrConfCallBack::~AttrConfCallBack() {
}

void AttrConfCallBack::push_event(Tango::AttrConfEventData *evento) {

    // most of the code is derived  (read copied) from cppTango/cppapi/rootattreg.cpp ...
    // that is from the implementation of some forwarded attribute features
    if (*replicator->rState == Tango::INIT)
        return;
    try {
        if (!evento->err) {
            string atnamefull = evento->attr_name;
            std::size_t pos = atnamefull.rfind("/");
            string atname = atnamefull.substr(++pos, string::npos);
            DEBUG_STREAM << "AttrConfEventCallback: " << atname.c_str() << " " << *replicator->rState;
            Tango::AttributeConfig_5 *ptr;
            ptr = Tango::AttributeConfigList_5::allocbuf(1);
            Tango::ApiUtil::AttributeInfoEx_to_AttributeConfig(evento->attr_conf, ptr);
            Tango::AttributeConfigList_5 conf_list(1, 1, ptr, false);
            conf_list[0].name = atname.c_str();
            conf_list[0].label = evento->attr_conf->label.c_str();
            conf_list[0].unit = evento->attr_conf->unit.c_str();
            conf_list[0].standard_unit = evento->attr_conf->standard_unit.c_str();
            conf_list[0].display_unit = evento->attr_conf->display_unit.c_str();
            conf_list[0].format = evento->attr_conf->format.c_str();
            conf_list[0].min_value = evento->attr_conf->min_value.c_str();
            conf_list[0].max_value = evento->attr_conf->max_value.c_str();
            conf_list[0].att_alarm.min_alarm = evento->attr_conf->alarms.min_alarm.c_str();
            conf_list[0].att_alarm.max_alarm = evento->attr_conf->alarms.max_alarm.c_str();
            conf_list[0].att_alarm.min_warning = evento->attr_conf->alarms.min_warning.c_str();
            conf_list[0].att_alarm.max_warning = evento->attr_conf->alarms.max_warning.c_str();
            conf_list[0].att_alarm.delta_t = evento->attr_conf->alarms.delta_t.c_str();
            conf_list[0].att_alarm.delta_val = evento->attr_conf->alarms.delta_val.c_str();
            Tango::ClntIdent ci;
            ci.cpp_clnt(0);
            replicator->set_attribute_config_5(conf_list, ci);
        } else {
            ERROR_STREAM << " event with error" << endl;

            for (unsigned int j = 0; j < evento->errors.length(); j++) {
                ERROR_STREAM << evento->errors[j].reason.in() << endl;
                ERROR_STREAM << evento->errors[j].origin.in() << endl;
                ERROR_STREAM << evento->errors[j].desc.in() << endl;
            }
        }

    } catch (Tango::DevFailed &e) {
        ERROR_STREAM<< "ATTR_CONF_EVENT Eccezione Tango nell' estrazione dati" << endl;
        Tango::Except::print_exception(e);
    } catch (...) {
        ERROR_STREAM << "ATTR_CONF_EVENT Eccezione generica nell' estrazione dati" << endl;
    }

}

}	//	namespace

