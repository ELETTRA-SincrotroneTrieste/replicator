static const char *RcsId =
        "$Header: /home/cvsadm/cvsroot/fermi/servers/replicator/src/ReplicatorClass.cpp,v 1.9 2019-05-09 09:42:35 claudio Exp $";
static const char *TagName = "$Name:  $";
static const char *HttpServer = "http://www.esrf.fr/computing/cs/tango/tango_doc/ds_doc/";
//+=============================================================================
//
// file :        ReplicatorClass.cpp
//
// description : C++ source for the ReplicatorClass. A singleton
//               class derived from DeviceClass. It implements the
//               command list and all properties and methods required
//               by the Replicator once per process.
//
// project :     TANGO Device Server
//
// $Author: claudio $
//
// $Revision: 1.9 $
//
// $Log: ReplicatorClass.cpp,v $
// Revision 1.9  2019-05-09 09:42:35  claudio
// #8723: scrittura bool, lettura/scrittura spctrum of long
//
// Revision 1.8  2019-03-19 12:58:22  claudio
// cleanup of unused methods
//
// Revision 1.7  2019-03-18 16:38:32  claudio
// first successful propagation of ATTR_CONF_EVENT
//
// Revision 1.6  2019-03-12 09:19:56  claudio
// prototype of static full configuration of replicated attributes
//
// Revision 1.5  2016-05-04 08:33:13  claudio
// tang9/device_5Impl
//
// Revision 1.4  2014-03-25 12:47:09  claudio
// Dev_4Impl
//
// Revision 1.3  2011/03/31 14:45:05  mdm
// Removed ping
//
// Revision 1.1.1.1  2009/12/09 13:24:29  mdm
// first import
//
//
// copyleft :   European Synchrotron Radiation Facility
//              BP 220, Grenoble 38043
//              FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================

#include <tango.h>

#include <Replicator.h>
#include <ReplicatorClass.h>

//+----------------------------------------------------------------------------
/**
 *	Create ReplicatorClass singleton and return it in a C function for Python usage
 */
//+----------------------------------------------------------------------------
extern "C" {
#ifdef WIN32

__declspec(dllexport)

#endif

Tango::DeviceClass *
_create_Replicator_class(const char *name) {
    return Replicator_ns::ReplicatorClass::init(name);
}
}

namespace Replicator_ns {

//+----------------------------------------------------------------------------
//
// method : 		GenericCommandClass::execute()
//
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *
GenericCommandClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any) {

    cout2 << "GenericCommandClass::execute(): arrived" << endl;

    return ((static_cast<Replicator *>(device))->generic_command(name, in_type, out_type, in_any));
}

//
//----------------------------------------------------------------
//	Initialize pointer for singleton pattern
//----------------------------------------------------------------
//
ReplicatorClass *ReplicatorClass::_instance = NULL;

//+----------------------------------------------------------------------------
//
// method : 		ReplicatorClass::ReplicatorClass(string &s)
//
// description : 	constructor for the ReplicatorClass
//
// in : - s : The class name
//
//-----------------------------------------------------------------------------
ReplicatorClass::ReplicatorClass(string &s) :
        DeviceClass(s) {

    cout2 << "Entering ReplicatorClass constructor" << endl;
    set_default_property();
    get_class_property();
    write_class_property();

    cout2 << "Leaving ReplicatorClass constructor" << endl;

}
//+----------------------------------------------------------------------------
//
// method : 		ReplicatorClass::~ReplicatorClass()
//
// description : 	destructor for the ReplicatorClass
//
//-----------------------------------------------------------------------------
ReplicatorClass::~ReplicatorClass() {
    _instance = NULL;
}

//+----------------------------------------------------------------------------
//
// method : 		ReplicatorClass::instance
//
// description : 	Create the object if not already done. Otherwise, just
//			return a pointer to the object
//
// in : - name : The class name
//
//-----------------------------------------------------------------------------
ReplicatorClass *
ReplicatorClass::init(const char *name) {
    if (_instance == NULL) {
        try {
            string s(name);
            _instance = new ReplicatorClass(s);
        } catch (bad_alloc&) {
            throw;
        }
    }
    return _instance;
}

ReplicatorClass *
ReplicatorClass::instance() {
    if (_instance == NULL) {
        cerr << "Class is not initialised !!" << endl;
        exit(-1);
    }
    return _instance;
}

//+----------------------------------------------------------------------------
//
// method : 		ReplicatorClass::command_factory
//
// description : 	Create the command object(s) and store them in the
//			command list
//
//-----------------------------------------------------------------------------
void ReplicatorClass::command_factory() {
    //command_list.push_back(new GenericCommandClass("GenericCommand",
    //	Tango::DEV_VOID, Tango::DEV_VOID,
    //	"",
    //	"",
    //	Tango::OPERATOR));

    //	add polling if any
    for (unsigned int i = 0; i < command_list.size(); i++) {
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ReplicatorClass::get_class_property
//
// description : 	Get the class property for specified name.
//
// in :		string	name : The property name
//
//+----------------------------------------------------------------------------
Tango::DbDatum ReplicatorClass::get_class_property(string &prop_name) {
    for (unsigned int i = 0; i < cl_prop.size(); i++)
        if (cl_prop[i].name == prop_name)
            return cl_prop[i];
    //	if not found, return  an empty DbDatum
    return Tango::DbDatum(prop_name);
}
//+----------------------------------------------------------------------------
//
// method : 		ReplicatorClass::get_default_device_property()
//
// description : 	Return the default value for device property.
//
//-----------------------------------------------------------------------------
Tango::DbDatum ReplicatorClass::get_default_device_property(string &prop_name) {
    for (unsigned int i = 0; i < dev_def_prop.size(); i++)
        if (dev_def_prop[i].name == prop_name)
            return dev_def_prop[i];
    //	if not found, return  an empty DbDatum
    return Tango::DbDatum(prop_name);
}

//+----------------------------------------------------------------------------
//
// method : 		ReplicatorClass::get_default_class_property()
//
// description : 	Return the default value for class property.
//
//-----------------------------------------------------------------------------
Tango::DbDatum ReplicatorClass::get_default_class_property(string &prop_name) {
    for (unsigned int i = 0; i < cl_def_prop.size(); i++)
        if (cl_def_prop[i].name == prop_name)
            return cl_def_prop[i];
    //	if not found, return  an empty DbDatum
    return Tango::DbDatum(prop_name);
}
//+----------------------------------------------------------------------------
//
// method : 		ReplicatorClass::device_factory
//
// description : 	Create the device object(s) and store them in the
//			device list
//
// in :		Tango::DevVarStringArray *devlist_ptr : The device name list
//
//-----------------------------------------------------------------------------
void ReplicatorClass::device_factory(const Tango::DevVarStringArray *devlist_ptr) {

    //	Create all devices.(Automatic code generation)
    //-------------------------------------------------------------
    for (unsigned long i = 0; i < devlist_ptr->length(); i++) {
        cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;

        // Create devices and add it into the device list
        //----------------------------------------------------
        device_list.push_back(new Replicator(this, (*devlist_ptr)[i]));

        // Export device to the outside world
        // Check before if database used.
        //---------------------------------------------
        if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
            export_device(device_list.back());
        else
            export_device(device_list.back(), (*devlist_ptr)[i]);
    }
    //	End of Automatic code generation
    //-------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//	Method: ReplicatorClass::attribute_factory(vector<Tango::Attr *> &att_list)
//-----------------------------------------------------------------------------
void ReplicatorClass::attribute_factory(vector<Tango::Attr *> &att_list) {

    //      Attribute : RState
    RStateAttrib *rstate = new RStateAttrib();
    att_list.push_back(rstate);

    //      Attribute : RStatus
    RStatusAttrib *rstatus = new RStatusAttrib();
    att_list.push_back(rstatus);
}

//+----------------------------------------------------------------------------
//
// method : 		ReplicatorClass::get_class_property()
//
// description : 	Read the class properties from database.
//
//-----------------------------------------------------------------------------
void ReplicatorClass::get_class_property() {
    //	Initialize your default values here (if not done with  POGO).
    //------------------------------------------------------------------

    //	Read class properties from database.(Automatic code generation)
    //------------------------------------------------------------------

    //	Call database and extract values
    //--------------------------------------------
    if (Tango::Util::instance()->_UseDb == true)
        get_db_class()->get_property(cl_prop);
    Tango::DbDatum def_prop;

    //	End of Automatic code generation
    //------------------------------------------------------------------

}

//+----------------------------------------------------------------------------
//
// method : 	ReplicatorClass::set_default_property
//
// description: Set default property (class and device) for wizard.
//              For each property, add to wizard property name and description
//              If default value has been set, add it to wizard property and
//              store it in a DbDatum.
//
//-----------------------------------------------------------------------------
void ReplicatorClass::set_default_property() {
    string prop_name;
    string prop_desc;
    string prop_def;

    vector<string> vect_data;
    //	Set Default Class Properties
    //	Set Default Device Properties
    prop_name = "AttributeList";
    prop_desc = "";
    prop_def = "";
    if (prop_def.length() > 0) {
        Tango::DbDatum data(prop_name);
        data << vect_data;
        dev_def_prop.push_back(data);
        add_wiz_dev_prop(prop_name, prop_desc, prop_def);
    } else
        add_wiz_dev_prop(prop_name, prop_desc);

    prop_name = "CommandList";
    prop_desc = "";
    prop_def = "";
    if (prop_def.length() > 0) {
        Tango::DbDatum data(prop_name);
        data << vect_data;
        dev_def_prop.push_back(data);
        add_wiz_dev_prop(prop_name, prop_desc, prop_def);
    } else
        add_wiz_dev_prop(prop_name, prop_desc);

    prop_name = "DeviceToReplicate";
    prop_desc = "";
    prop_def = "";
    if (prop_def.length() > 0) {
        Tango::DbDatum data(prop_name);
        data << vect_data;
        dev_def_prop.push_back(data);
        add_wiz_dev_prop(prop_name, prop_desc, prop_def);
    } else
        add_wiz_dev_prop(prop_name, prop_desc);

}
//+----------------------------------------------------------------------------
//
// method : 		ReplicatorClass::write_class_property
//
// description : 	Set class description as property in database
//
//-----------------------------------------------------------------------------
void ReplicatorClass::write_class_property() {
    //	First time, check if database used
    //--------------------------------------------
    if (Tango::Util::_UseDb == false)
        return;

    Tango::DbData data;
    string classname = get_name();
    string header;
    string::size_type start, end;

    //	Put title
    Tango::DbDatum title("ProjectTitle");
    string str_title("Device Replicator");
    title << str_title;
    data.push_back(title);

    //	Put Description
    Tango::DbDatum description("Description");
    vector<string> str_desc;
    str_desc.push_back("  ");
    description << str_desc;
    data.push_back(description);

    //	put cvs location
    string rcsId(RcsId);
    string filename(classname);
    start = rcsId.find("/");
    if (start != string::npos) {
        filename += "Class.cpp";
        end = rcsId.find(filename);
        if (end > start) {
            string strloc = rcsId.substr(start, end - start);
            //	Check if specific repository
            start = strloc.find("/cvsroot/");
            if (start != string::npos && start > 0) {
                string repository = strloc.substr(0, start);
                if (repository.find("/segfs/") != string::npos)
                    strloc = "ESRF:" + strloc.substr(start, strloc.length() - start);
            }
            Tango::DbDatum cvs_loc("cvs_location");
            cvs_loc << strloc;
            data.push_back(cvs_loc);
        }
    }

    //	Get CVS tag revision
    string tagname(TagName);
    header = "$Name: ";
    start = header.length();
    string endstr(" $");
    end = tagname.find(endstr);
    if (end != string::npos && end > start) {
        string strtag = tagname.substr(start, end - start);
        Tango::DbDatum cvs_tag("cvs_tag");
        cvs_tag << strtag;
        data.push_back(cvs_tag);
    }

    //	Get URL location
    string httpServ(HttpServer);
    if (httpServ.length() > 0) {
        Tango::DbDatum db_doc_url("doc_url");
        db_doc_url << httpServ;
        data.push_back(db_doc_url);
    }

    //  Put inheritance
    Tango::DbDatum inher_datum("InheritedFrom");
    vector<string> inheritance;
    inheritance.push_back("TANGO_BASE_CLASS");
    inher_datum << inheritance;
    data.push_back(inher_datum);

    //	Call database and and values
    //--------------------------------------------
    get_db_class()->put_property(data);
}

// Builders
GenericScalarAttrib::GenericScalarAttrib(const char *name, long data_type, Tango::AttrWriteType w_type, const char *assoc,
        Tango::AttributeInfoEx& attinfo) :
        Attr(name, data_type, w_type, assoc) {
    Tango::UserDefaultAttrProp dfltprop;
    dfltprop.set_label(attinfo.label.c_str());
    dfltprop.set_unit(attinfo.unit.c_str());
    dfltprop.set_standard_unit(attinfo.standard_unit.c_str());
    dfltprop.set_display_unit(attinfo.display_unit.c_str());
    dfltprop.set_format(attinfo.format.c_str());
    dfltprop.set_min_value(attinfo.min_value.c_str());
    dfltprop.set_max_value(attinfo.max_value.c_str());
    dfltprop.set_min_alarm(attinfo.alarms.min_alarm.c_str());
    dfltprop.set_max_alarm(attinfo.alarms.max_alarm.c_str());
    dfltprop.set_min_warning(attinfo.alarms.min_warning.c_str());
    dfltprop.set_max_warning(attinfo.alarms.max_warning.c_str());
    dfltprop.set_delta_t(attinfo.alarms.delta_t.c_str());
    dfltprop.set_delta_val(attinfo.alarms.delta_val.c_str());
    set_default_properties(dfltprop);
}

GenericScalarAttrib::~GenericScalarAttrib() {
}
//-------------------------------------------------------------------------

GenericSpectrumAttrib::GenericSpectrumAttrib(const char *name, long data_type, Tango::AttrWriteType w_type, long max_x,
        Tango::AttributeInfoEx& attinfo) :
        SpectrumAttr(name, data_type, w_type, max_x) {
    Tango::UserDefaultAttrProp dfltprop;
    dfltprop.set_label(attinfo.label.c_str());
    dfltprop.set_unit(attinfo.unit.c_str());
    dfltprop.set_standard_unit(attinfo.standard_unit.c_str());
    dfltprop.set_display_unit(attinfo.display_unit.c_str());
    dfltprop.set_format(attinfo.format.c_str());
    dfltprop.set_min_value(attinfo.min_value.c_str());
    dfltprop.set_max_value(attinfo.max_value.c_str());
    dfltprop.set_min_alarm(attinfo.alarms.min_alarm.c_str());
    dfltprop.set_max_alarm(attinfo.alarms.max_alarm.c_str());
    dfltprop.set_min_warning(attinfo.alarms.min_warning.c_str());
    dfltprop.set_max_warning(attinfo.alarms.max_warning.c_str());
    dfltprop.set_delta_t(attinfo.alarms.delta_t.c_str());
    dfltprop.set_delta_val(attinfo.alarms.delta_val.c_str());
    set_default_properties(dfltprop);
    //cout <<name<< " "<< w_type<< " " << max_x << " " << __FILE__ << " " << __LINE__ << endl;
}

GenericImageAttrib::GenericImageAttrib(const char *name, long data_type, Tango::AttrWriteType w_type, long max_x, long max_y,
        Tango::AttributeInfoEx& attinfo) :
        ImageAttr(name, data_type, w_type, max_x, max_y) {
    Tango::UserDefaultAttrProp dfltprop;
    dfltprop.set_label(attinfo.label.c_str());
    dfltprop.set_unit(attinfo.unit.c_str());
    dfltprop.set_standard_unit(attinfo.standard_unit.c_str());
    dfltprop.set_display_unit(attinfo.display_unit.c_str());
    dfltprop.set_format(attinfo.format.c_str());
    dfltprop.set_min_value(attinfo.min_value.c_str());
    dfltprop.set_max_value(attinfo.max_value.c_str());
    dfltprop.set_min_alarm(attinfo.alarms.min_alarm.c_str());
    dfltprop.set_max_alarm(attinfo.alarms.max_alarm.c_str());
    dfltprop.set_min_warning(attinfo.alarms.min_warning.c_str());
    dfltprop.set_max_warning(attinfo.alarms.max_warning.c_str());
    dfltprop.set_delta_t(attinfo.alarms.delta_t.c_str());
    dfltprop.set_delta_val(attinfo.alarms.delta_val.c_str());
    set_default_properties(dfltprop);
}





}	// namespace
